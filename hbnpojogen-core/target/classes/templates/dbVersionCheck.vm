package ${packagename};

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.hibernate.SessionFactory;
import org.hibernate.impl.SessionFactoryImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/** Checks one or more database tables to make sure that the version matches
 * with the one read during code generation stage. 
 * @author autogenerated
 *
 */
@Component
public class DBVersionCheck$beanname {
	/** Query to execute. */
	private static final String QUERY = "SELECT %s FROM %s %s %s";
	/** Error message. */
	private static final String SQLERROR = "Error while checking DB version (Query tried: %s).";
	/** Major version identifier. */ 
	private static final String MAJORIDENTIFIER = "0";
	/** Error message. */
	private static String ERROR = "\n---------------------------------------\nError: The DB version found by reading table %s does not match " +
			"the one read during code generation.\n You _MUST_ use the same database that was used during model generation. \n" +
			"Do ***NOT*** modify db_version table manually to make this error go away for it will only make the application fail at other places.\n" +
			"You should check that you have applied your DB alter scripts correctly and that the model class files match." +
			"\nQuery used was: %s.\nExpected: %s. \n    Read: %s\nJDBC URL: %s\nUsername: %s\n---------------------------------------\n";
	/** The table name to check. */
	private static String tableName = "${tableName}";
	/** User-specified where clause to append to the query. */
	private static String whereClauseFilter = "${whereClause}";
	/** User-specified order clause to append to the query. */
	private static String orderBy = "${orderBy}";
	/** The fields to check. */
	private VersionRowList versionRows = new VersionRowList();
	/** Log4j handle. */
	private Logger log = LoggerFactory.getLogger(DBVersionCheck${beanname}.class);
	/** Columns we're interested in. */
	private List<String> whereClauses = new LinkedList<String>();
	
	/** Constructor where everything starts off from.
	 * @param sf Session factory handle
	 */
	@Autowired
	public DBVersionCheck$beanname (SessionFactory sf) {
		Connection conn = null;
		String query = "";
		ResultSet rs = null;
		Statement statement = null;

#foreach ($clause in $versionColumns)
        this.whereClauses.add("$clause");
#end
		try {
			/* The following items were read from the DB during code generation time. */
#foreach ($clause in $versionsRead)
			this.versionRows.add(new VersionRow($this.convertListToStringList($clause)));
#end

			// Get a JDBC connection handle from hibernate.
			conn = ((SessionFactoryImpl)sf).getConnectionProvider().getConnection();

			StringBuffer whereClause = new StringBuffer();
			// Go through all the mappings
			for (String clause: this.whereClauses){
				whereClause.append(filterSign(clause));
				whereClause.append(", ");
			}
			// remove last "And"
			if (whereClause.length() == -1) {
				String error = "Could not determine 'where clause' for dbversion check";
				this.log.error(error);
				throw new RuntimeException(error);
			}
			whereClause.setLength(whereClause.length()-2);
			// run the query
			query = String.format(QUERY, whereClause, tableName, whereClauseFilter, orderBy);
			statement = conn.createStatement();
            rs = statement.executeQuery(query);


			List<VersionRow> results = new ArrayList<VersionRow>($versionsRead.size());
			Integer dbMajorCount = 0;
			boolean foundMatch = true;
			
			// Check for result
			while (rs.next()){
				results.add(new VersionRow(#foreach ($col in $versionColumns)rs.getString("$col")#if ($velocityCount < $versionColumns.size()), 
										   #end#end));
										   
				if (rs.getString("minor").equals(MAJORIDENTIFIER)) {

                    dbMajorCount++;
                }
			}
			
			// Check major version count.
            if (!this.versionRows.majorVersionCount.equals(dbMajorCount)) {

                foundMatch = false;
            }
			
			if (foundMatch) {
			
				int i=0;
				for (VersionRow versionRow: this.versionRows.versionRowList){
					if (i >= results.size() || !results.get(i++).equals(versionRow)){
						foundMatch = false;
						break;
					}
				}
			}


			if (!foundMatch) {
				// no results. We failed to find a match
				String error = String.format(ERROR, tableName, query, this.versionRows.versionRowList, results, conn.getMetaData().getURL(), conn.getMetaData().getUserName());
				this.log.error(error);
				throw new RuntimeException(error);
			}
		} catch (SQLException e) {
			String err = String.format(SQLERROR, query);
			this.log.error(err, e);
			throw new RuntimeException(err);
		}  finally {
			try{
				if (statement != null) {
					statement.close();
				}
				if (rs != null) {
					rs.close();
				}
				if (conn != null) {
					conn.close();
				}
				
			} catch (Exception e) {
				String err = "Error closing connection";
				this.log.error(err, e);
				throw new RuntimeException(err);
			}
		}
	}
	
	/** Filter >= sign 
	 * @param clause
	 * @return a filtered string
	 */
	private String filterSign(String clause){
		String result = clause;
		if (clause.startsWith(">=")){
			result = clause.substring(2);
		}
		
		return result;
	}
	
	/** Version Check helper class */
	public class VersionRow{
#foreach ($clause in $versionColumns)
		/** Column in version table. */
		public String $clause;
#end

		/** VersionRow constructor.
#foreach ($clause in $versionColumns)		
		 * @param $clause Column
#end		 
		 */
		public VersionRow(#foreach ($clause in $versionColumns)String $clause#if ($velocityCount < $versionColumns.size()), #end#end){
#foreach ($clause in $versionColumns)
			this.$clause = $clause;
#end		
		}
		
		/** Equals method taking care of >= sign too if necessary
		 * @param other
		 * @return true/false
		 */
		public boolean equals(VersionRow other){
			return
#foreach ($clause in $versionColumns)
#if ($gteVersions.contains($clause))
				Integer.parseInt(this.${clause}) >= Integer.parseInt(other.$clause)
#else
				this.${clause}.equals(other.$clause)
#end				
#if ($velocityCount < $versionColumns.size())
			 &&
#else
			;
#end
#end			

		}
		
		@Override
		public String toString() {
			StringBuffer sb = new StringBuffer();
			
			sb.append("[");
#foreach ($clause in $versionColumns)		
			sb.append("$clause");
#if ($gteVersions.contains($clause))			
			sb.append(">=");
#else			
			sb.append("=");
#end			
			sb.append(this.$clause);
#if ($velocityCount < $versionColumns.size())
			sb.append(", ");
#end
#end
			sb.append("]");

			return sb.toString();			
		}
	}
	
	    /** Version Check helper class */
    public class VersionRowList {


        public List<VersionRow> versionRowList = new ArrayList<VersionRow>();
        public Integer majorVersionCount = 0;



        /**
         * VersionRow constructor.
         * 
         * @param alter_no Column
         * @param branch Column
         * @param minor Column
         */
        public void add(VersionRow versionRow) {

            this.versionRowList.add(versionRow);
            if (versionRow.minor.equals(MAJORIDENTIFIER)) {

                this.majorVersionCount++;
            }
        }
    }
	
}
