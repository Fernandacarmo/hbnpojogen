package ${packagename};

#foreach ($import in $imports)
import $import;
#end
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import java.util.Collection;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import com.felees.hbnpojogen.randomlib.data.dataGeneration.BasicDataGenerator;


/** 
 * DAO factory implementation.
 * @author autogenerated
 */
@Component
public class ${prettyCatalog}DataPoolFactory implements ApplicationContextAware {
	/** Table commit order. */
    private static final Multimap<String, String> tableDeps = ArrayListMultimap.create();
	/** DB commit order. */
	private static final String[] commitOrder = new String[]{$commitOrder};
#if ($hasImmutable && !$springData) 	
	/** DataLayer handle. */
	private static ${classes.values().iterator().next().getDataLayerInterfaceClassName()} dataLayer;
#end	
	static{
		// Store table deps for possible use. 
#foreach ($entry in $tableDeps)
#foreach ($dep in $entry.getValue())
#if (!$this.getClassName($dep).equals("")) 
 		tableDeps.put("$this.getClassName($entry.getKey())", "$this.getClassName($dep)");
#end
#end
#end
	}
	
	/** For cyclic classes. */
	static ApplicationContext context;
	 
	public void setApplicationContext(ApplicationContext ctx){
	    context = ctx;
	}



## Add reference to Hibernate Factory - chrisp
#foreach ($class in $classes)
#if ($class.isCyclicExclusionReplacementTable())
	/** Used for bootstrap only. Loads the first record from DB to break the cyclic dependency. Will fail if no data is present. 
	* @return $class.className record.
	*/
	private static $class.className getHbnPjoBootstrap${class.className}() {
#if (!$springData)
		 return ${class.getHibernateDAO()}.get${class.getMaybeExpandDAO()}().load(${class.getBootstrapHelper()}); 
#else

		 return ((${class.getRepositoryClassName()})context.getBean("${class.getRepositoryClassNamePropertyName()}")).findOne(1#if ($class.getTypeOfId().equals("Long"))L#end); 
#end

	} 

#end
#end
#if ($hasImmutable && !$springData) 
    /**
     * Default constructor.
     *
     * @param dataLayer Data Layer handle.
     */
    @Autowired
    public ${prettyCatalog}DataPoolFactory(${classes.values().iterator().next().getDataLayerImplFullClassName()} dataLayer) {
        ${prettyCatalog}DataPoolFactory.dataLayer = dataLayer;
    }
#end
#foreach ($class in $classes)
#if ($class.isImmutableAndNotStaticTest())
#if ( (! $class.hiddenJoinTable ) && ($class.classType != "abstract") )
    /**
     * Data pool factory for ${class.className}. Class is marked as immutable
     * so load the first record from the DB instead.
     * @return ${class.className} A ${class.className} object
     */
    public static ${class.className} get${class.className}() {
#if (!$springData)
    
        return (${class.className}) dataLayer.createQuery("from ${class.className} where id > 0")
            .setMaxResults(1)
            .uniqueResult();
#else
    		 return ((${class.getRepositoryClassName()})context.getBean("${class.getRepositoryClassNamePropertyName()}")).findAll(new PageRequest(0, 1)).getContent().get(0); 
#end                    
    }
#end
#else
## Do not create getters for abstract classes - chrisp
#if ( (! $class.hiddenJoinTable ) && ($class.classType != "abstract") ) 
#set($doneAtLeastOneManyToOne = ${class.containsAManyToOneProperty()} || ${class.containsAOneToOnePropertyWithoutInverseSide()} )

############### We have no dependent tables
#if ($doneAtLeastOneManyToOne == false)   
    /**
     * Data pool factory for ${class.className}.
     * @return ${class.className}A ${class.className} object
     */
    public static ${class.className} get${class.className}() {

        ${class.className} $class.ClassPropertyName = new ${class.className}();    
        
#foreach ($property in $class.getAllPropertiesWithoutPFK())
#if (($property.isTestValueOverride() == true) ||  (($property.isGeneratedValue() == false) && ($property.oneToMany == false) && ($property.ManyToMany == false) && (!$property.isOneTooneInverseSide())))
        ${class.ClassPropertyName}.set${property.javaName}(${this.getGeneratorString($property)});
#set($doneAtLeastOneField = 1)
#end
#end

        return ${class.ClassPropertyName};
    }
#end
############# If we have a many-to-one, generate different code
#if ($doneAtLeastOneManyToOne == true)   
    /**
     * Data pool factory for ${class.className}.
     * @return ${class.className} A ${class.className} object
     */
    public static ${class.className} get${class.className}() {

#set($passedProperties=$class.countManyToOneAndCompositePropertiesAndOneToOne())
########## Fill in the params
        ${class.className} ${class.ClassPropertyName} =  get${class.className}(
	        #foreach ($property in $class.getAllPropertiesWithoutPFK())
#if (  ($property.composite) || (($property.manyToOne == true) && ($property.isGeneratedValue() == false)) || (($property.oneToOne == true) && ($property.isOneTooneInverseSide() == false) && ($property.isGeneratedValue() == false)) )#set($passedProperties=$passedProperties - 1)${this.getGeneratorString($class, $classes, $property)}#if ( $passedProperties > 0), #end#end#end);

		return ${class.ClassPropertyName};
       
    }

################# This method will generate the same version but accepting parameters for related tables instead 
     /**
     * Data pool factory for ${class.className}.
#foreach ($property in $class.getAllPropertiesWithoutPFK())#if ($property.manyToOne == true)
     * @param $property.propertyName A valid ${property.getManyToOneLink().clazz.className} object
#end
#if ( ($property.isGeneratedValue() == false) && ($property.oneToMany == false) && ($property.ManyToMany == false) && (!$property.isOneTooneInverseSide()))
#if ($property.OneToOne == true)
     * @param $property.propertyName A valid ${property.getOneToOneLink().clazz.className} object
#end
#end
#if ($property.composite == true)
	 * @param id The Composite Primary key
#end
#end
     * @return ${class.className} A ${class.className} object
     */
    public static ${class.className} get${class.className}(${this.getDAOSignature($class)}) {
        ${class.className} ${class.ClassPropertyName} = new ${class.className}();     
#foreach ($property in $class.getAllPropertiesWithoutPFK())
#if ( ($property.isGeneratedValue() == false || $property.isTestValueOverride() == true) && ($property.oneToMany == false) && ($property.ManyToMany == false) && (!$property.isOneTooneInverseSide()))
#if ($class.isEmbeddable() == false && $property.enumType == false && $property.isManyToOne() == true && $property.isInverseLinkDisabled() == false  && $this.isBacklinksDisabled() == false)
		if (${property.propertyName} != null) {
			${property.propertyName}.add${this.getManyToOneSuperClass($class, $property)} (${class.ClassPropertyName});
		}
#else		
        ${class.ClassPropertyName}.set${property.javaName}(${this.getGeneratorString($property, true)});
#end
#set($doneAtLeastOneField = 1)
#end
#end

        return ${class.ClassPropertyName};
    }
#end
#end
#end
#end	
    /** Returns the commit order of this database. 
	 * Useful for iterating through the classes for deletion in the right order. 
	 * @return String[] list of classes
	 */
	public static String[] getDBCommitOrder() {
		return commitOrder;
	}
	
	/**
	 * @param className classname to return
	 * @return the tabledeps for the given class name
	 */
	public static Collection<String> getTabledeps(String className) {
		return tableDeps.get(className);
	}
	
}
