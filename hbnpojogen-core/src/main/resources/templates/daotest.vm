package ${toplevel};

import org.junit.Assert;
import org.junit.Test;

#if ( ! ($prepopulate.isEmpty() && $preExec.isEmpty()) )
import java.sql.*;
#end

#foreach ($import in $imports)
import $import;
#end
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.junit.runner.RunWith;
import org.springframework.transaction.annotation.Transactional;
#if ($disableTestRollback)
import org.springframework.test.annotation.Rollback;
#end

/** Hibernate tester.
* @author autogenerated
*/
@SuppressWarnings("cast")
@ContextConfiguration(locations = { "/$appContextFilename" } )
@RunWith(SpringJUnit4ClassRunner.class)
public class DAOIntegrationTest {
		
#macro(doprefix)
#if ( $property.isBooleanField() )is#{else}get#end
#end
#macro(doSuffix)
#if ( $property.oneToMany || $property.manyToMany )s#end
#end
#macro(custom $title)
#if ( ! $preExec.isEmpty())
	/** Executes custom statements manually into the database (without hibernate). 
	* These entries come straight from the hibernate synchronizer config file 
	* @throws SQLException on sql error
	* @throws ClassNotFoundException on missing driver error 
	*/ 
	@Test
	public void customFromConfig$title() throws SQLException, ClassNotFoundException{
#foreach( $item in $preExec )
#if ($velocityCount == 1)
	    Connection con=null;
	    Statement stmt=null;
    
    	try{
	    	Class.forName("$item.driver");
    
    
#end 
    		con = DriverManager.getConnection("$item.connectionURL","$item.connectionUsername", "$item.connectionPassword");
			stmt = con.createStatement();	
#foreach( $statement in $item.statements )
			stmt.executeUpdate("$statement");
#end
#end
		}finally{
			if (stmt != null) {
				stmt.close();
			}
			if (con != null) {
				con.close();
			}
		}
	}
#end
#end
#macro(customPost $title)
#if ( ! $prepopulate.isEmpty())
	/** Executes custom statements manually into the database (without hibernate). 
	* These entries come straight from the hibernate synchronizer config file 
	* @throws SQLException on sql error
	* @throws ClassNotFoundException on missing driver error 
	*/ 
	@Test
	public void customFromConfig$title() throws SQLException, ClassNotFoundException{
#foreach( $item in $prepopulate )
#if ($velocityCount == 1)
	    Connection con=null;
	    Statement stmt=null;
    
    	try{
	    	Class.forName("$item.driver");
    
    
#end 
    		con = DriverManager.getConnection("$item.connectionURL","$item.connectionUsername", "$item.connectionPassword");
			stmt = con.createStatement();	
#foreach( $statement in $item.statements )
			stmt.executeUpdate("$statement");
#end
#end
		}finally{
			if (stmt != null) {
				stmt.close();
			}
			if (con != null) {
				con.close();
			}
		}
	}
#end
#end
#macro(cleanup $title $firstPass)
#if (!$disableCleanTables)
	/**
	 * Clears the database.
	 */
	@Test
	@Transactional
	public void $title() {
#if ($firstPass == "1")
#if (!$tableSetCycles.isEmpty())
		boolean hadFailure=false;
		
#end
		// We'll ignore any exceptions in this pass to give time for the custom exec to execute too 
		// (+ clear out any DB loops)
#end
	
#foreach ( $table in $tablesReverse )
#if ($firstPass == "1")
		try{${table.Value.clazz.getHibernateDAO()}.get${table.Value.clazz.className}Dao().getQuery("delete from ${table.Value.clazz.getMaybeExpandClassName()}").executeUpdate(); } catch (Exception e) { /* do nothing */ }
#else
		${table.Value.clazz.getHibernateDAO()}.get${table.Value.clazz.className}Dao().getQuery("delete from ${table.Value.clazz.getMaybeExpandClassName()}").executeUpdate();
#end
#end

#if ($firstPass == "1")
#if (!$tableSetCycles.isEmpty())
		
		// we have a DB loop. Cycle through links trying to delete until we have no more errors	
#end
#foreach ( $classSet in $tableSetCycles )
		do{
			hadFailure=false;
#foreach ( $class in $classSet )
			try{${class.getHibernateDAO()}.get${class.className}Dao().getQuery("delete from ${class.getMaybeExpandClassName()}").executeUpdate(); } catch (Exception e) { hadFailure=true;}
#end
		} while( hadFailure );
		
#end
#end

		
	}
#end
#end

#custom("PreExec")
#cleanup("testPreCleanDBFirstPass" "1")
#cleanup("testPreCleanDBFinalPass" "0")

#if ( ! $prepopulate.isEmpty())
	/** Inserts items manually into the database (without hibernate). 
	* These entries come straight from the hibernate synchronizer config file 
	* @throws SQLException on sql error
	* @throws ClassNotFoundException on missing driver error 
	*/ 
	@Test
	public void populateExternal() throws SQLException, ClassNotFoundException{
#foreach( $item in $prepopulate )
#if ($velocityCount == 1)
	    Connection con=null;
	    Statement stmt=null;
    	try{
	    	Class.forName("$item.driver");
    
    
#end 
    		con = DriverManager.getConnection("$item.connectionURL","$item.connectionUsername", "$item.connectionPassword");
			stmt = con.createStatement();	
#foreach( $statement in $item.statements )
			stmt.executeUpdate("$statement");
#end
#end
		}finally{
			if (stmt != null) {
				stmt.close();
			}
			if (con != null) {
				con.close();
			}
		}
	}
#end
	
#foreach ( $class in $classes )
## Do not create getters for abstract classes - chrisp
#if (! $class.isEmbeddable() && !$class.isHiddenJoinTable() && (!$class.isAbstractClass()) && (!$class.isTableIsAView()) )
	/**
	 * Hibernate test case for table: ${class.tableObj.getFullTableName()}.
	 * @throws CloneNotSupportedException on clone error
	 */
	@Transactional
#if ($disableTestRollback )
	@Rollback(false)
#end
	@Test		
	public void test#if(${class.isNameAmbiguityPossible()})${class.classPackage}#end${class.className}() throws CloneNotSupportedException {

##
##Hibernate Factory getter
##
	 	$class.getDataLayerInterfaceClassName() $class.getDataLayerInterfaceClassNameProperty() = ${class.getDataLayerImplClassName()}.getInstance();
		${class.getMaybeExpandClassName()} ${class.tableObj.testHandle} = ${class.getDataPoolFactory()}.get${class.className}();
#foreach ($item in $this.getUncascaded($class, ${class.tableObj.testHandle}))
		// Cascading on this property was switched off from config (or requires hbn bug workaround). Performing manual cascade.
		$item;
#end
		${class.getDataLayerInterfaceClassNameProperty()}.saveOrUpdate(${class.tableObj.testHandle});

		${class.getTypeOfId()} ${class.tableObj.testHandle}Id = ${class.tableObj.testHandle}.getId();
		${class.getMaybeExpandClassName()} copy = ${class.tableObj.testHandle}.clone();
		${class.getDataLayerInterfaceClassNameProperty()}.flushSession(); // flush+evict from cache to make sure we hit the DB next 
		${class.getDataLayerInterfaceClassNameProperty()}.evict(${class.tableObj.testHandle}); 		 

		${class.tableObj.testHandle} = ${class.getDataLayerInterfaceClassNameProperty()}.get${class.className}(${class.tableObj.testHandle}Id); 	// load it again


		// Validity checks
##
## Assert Section
##
		Assert.assertNotNull(copy);
		// null equals check
		Assert.assertFalse(copy.equals(null));
		
#foreach ($property in ${class.getAllPropertiesWithoutPFKNoBackLinks()} )
#if (!($property.isTransientField()))
#if ( ($property.autoInc == false) && (!$property.isOneToOne()))
#if ($property.ManyToOne )
#set($nullcheck = ${this.getGeneratorString($property, false)})
#if ($nullcheck != "null")		
		Assert.assertEquals(copy.get${property.javaName}().getId(), ${class.tableObj.testHandle}.get${property.javaName}().getId());
#end
#else
##
## If it's a float,real,decimal or double, use delta for assert
#if (($property.fieldObj.fieldType == 6) || ($property.fieldObj.fieldType == 7) || ($property.fieldObj.fieldType== 8) )
		Assert.assertEquals(copy.get${property.javaName}(), ${class.tableObj.testHandle}.get${property.javaName}(), 0.1);
#else
## If it's a date, time or timestamp, fudge with the result coz nanosecs don't map cleanly on jdbc
#if ( ($property.fieldObj.fieldType == 91) || ($property.fieldObj.fieldType == 92) || ($property.fieldObj.fieldType == 93)  )
### if it's a date we need to chuck out the time
#set($timebit = ".getTime()")
#if ($property.getJavaType().equals("DateTime"))
#set($timebit = ".toDate().getTime()")
#end
#if ($property.fieldObj.fieldType == 91)
		Assert.assertEquals(new java.text.SimpleDateFormat("dd/MM/yyyy").format(copy.get${property.javaName}()$timebit), new java.text.SimpleDateFormat("dd/MM/yyyy").format(${class.tableObj.testHandle}.get${property.javaName}()$timebit));
#else
#set ($bounce = "") 
#if ($property.clazz.compositePrimaryKey && $property.idField)
#set ($bounce = ".get" + ${property.fieldObj.property.javaName} + "()")
#if ($property.fieldObj.property.getJavaType().equals("DateTime"))
#set($timebit = ".toDate().getTime()")
#end
#end		
		Assert.assertTrue(copy.get${property.javaName}()${bounce}$timebit / 1000 - ${class.tableObj.testHandle}.get${property.javaName}()${bounce}$timebit / 1000 < 100);
#end
#else
#if ($property.ManyToMany)
		Assert.assertTrue(copy.#doprefix()${property.niceJavaName}().equals(${class.tableObj.testHandle}.#doprefix()${property.niceJavaName}()));
#else
#set($nullcheck = ${this.getGeneratorString($property, false)})
#if ($nullcheck != "null")	
#if (!($property.fieldObj.fieldType == -3) )  
## not Byte[] check - deprecated in junit4.4
		Assert.assertEquals(copy.#doprefix()${property.niceJavaName}(), ${class.tableObj.testHandle}.#doprefix()${property.niceJavaName}());
#end
#end
#end
#end
#end
#end
#end
#end
#end
		// tests for coverage completeness
		Assert.assertFalse(${class.tableObj.testHandle}.toString().equals(""));
		Assert.assertEquals(copy, copy.clone());
		// symmetric equality check
		Assert.assertEquals(copy.clone(), copy);
		// reflexive equality check
		Assert.assertEquals(copy, copy);
		// hashcode on identical object should return same number
		Assert.assertEquals(${class.tableObj.testHandle}.hashCode(), copy.hashCode());  
		Assert.assertNotSame(copy, 0L);
	  // End of table
	}
#end
#end 

#cleanup("testPostCleanDBFirstPass" "1")

#cleanup("postCleanDBFinalPass" "0")		

}

