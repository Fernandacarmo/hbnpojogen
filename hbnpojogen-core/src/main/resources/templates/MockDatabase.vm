package ${packagename};


import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import ${repositoryClass};
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.springframework.test.util.ReflectionTestUtils;

import java.io.Serializable;
import java.util.List;
import java.util.Map;
import java.util.Random;

import static org.mockito.Matchers.anyObject;
import static org.mockito.Mockito.*;

/**
 * Helper class for use in tests to fake the existence of a database. 
 *
 * autogenerated
 */
public class MockDatabase<T> {

    protected Map<Serializable, T> fakeDatabase = Maps.newHashMap();

    private final CustomRepository<T,Serializable> repository;



    public <ID extends Serializable> MockDatabase(CustomRepository<T, ID> repository){
        this.repository = (CustomRepository<T, Serializable>) repository;


        reset(repository);
        doAnswer(new Answer<Object>() {
            @Override
            public Object answer(InvocationOnMock invocation) throws Throwable {
                fakeDatabase.clear();
                return null;
            }
        }).when(repository).deleteAll();

        when(repository.save((T) anyObject())).thenAnswer(new Answer<T>() {
            @Override
            public T answer(InvocationOnMock invocation) throws Throwable {
                return saveOrSaveAndFlush(invocation);
            }
        });


        when(repository.getReference((ID)anyObject())).thenAnswer(new Answer<T>() {
            @Override
            public T answer(InvocationOnMock invocation) throws Throwable {
                return fakeDatabase.get(invocation.getArguments()[0]);
            }
        });

       when(repository.findOne((ID)anyObject())).thenAnswer(new Answer<T>() {
           @Override
           public T answer(InvocationOnMock invocation) throws Throwable {
               return fakeDatabase.get(invocation.getArguments()[0]);
           }
       });

        doAnswer(new Answer<T>() {
            @Override
            public T answer(InvocationOnMock invocation) throws Throwable {
                return fakeDatabase.remove(ReflectionTestUtils.invokeGetterMethod(invocation.getArguments()[0], "getId"));
            }
        }).when(repository).delete((T)anyObject());


        doAnswer(new Answer<ID>() {
            @Override
            public ID answer(InvocationOnMock invocation) throws Throwable {
               fakeDatabase.remove(((ID)invocation.getArguments()[0]));
                return null;
            }
        }).when(repository).delete((ID)anyObject());


        when(repository.saveAndFlush((T) anyObject())).thenAnswer(new Answer<T>() {
            @Override
            public T answer(InvocationOnMock invocation) throws Throwable {
                return saveOrSaveAndFlush(invocation);
            }


        });

        when(repository.exists((ID)anyObject())).thenAnswer(new Answer<Boolean>() {
            @Override
            public Boolean answer(InvocationOnMock invocation) throws Throwable {
                return fakeDatabase.containsKey(invocation.getArguments()[0]);
            }
        });


        when(repository.findAll()).thenAnswer(new Answer<List<T>>() {
            @Override
            public List<T> answer(InvocationOnMock invocation) throws Throwable {
                return Lists.newLinkedList(fakeDatabase.values());
            }
        });

        customMethods();

    }

    private T saveOrSaveAndFlush(InvocationOnMock invocation) throws NoSuchMethodException {
        Object[] args = invocation.getArguments();
        Serializable id = (Serializable) ReflectionTestUtils.getField(args[0], "id");
        if (id == null) {
            Class<?> returnType = args[0].getClass().getMethod("getId").getReturnType();

            if (returnType.equals(Long.class)) {
                id = (Long) new Random().nextLong();
            } else if (returnType.equals(Integer.class)) {
                id = (Integer) new Random().nextInt();
            }
            ReflectionTestUtils.setField(args[0], "id", id);
        }

        fakeDatabase.put(id, (T) args[0]);

        return (T) args[0];
    }

    public void customMethods() {
        // override here if you want
    }

}


